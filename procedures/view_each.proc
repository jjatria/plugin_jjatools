# View each selected Sound (and TextGrid) object in turn
#
# The script allows for easy navigation between selected Sound
# objects, which is particularly useful when comparing specific
# features in each of them. If an equal number of TextGrid and
# Sound objects have been selected, they will be paired by name
# and viewed in unison.
#
# Written by Jose J. Atria (October 14, 2012)
# Last revision: July 10, 2014)
#
# This script is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# A copy of the GNU General Public License is available at
# <http://www.gnu.org/licenses/>.

include ../../plugin_jjatools/procedures/selection.proc

procedure viewEach (.base, .pair, .i, .n)
  nocheck selectObject: .base
  if numberOfSelected()
    .base_type$   = extractWord$(selected$(), "")
    .base_name$   = selected$(.base_type$)
    .editor_name$ = selected$()

    if .pair != undefined and .pair
      selectObject: .pair
      .pair_type$   = extractWord$(selected$(), "")
      .pair_name$   = selected$(.pair_type$)
      .editor_name$ = selected$()
      selectObject: .base, .pair
    endif

    @viewEach_atBeginIteration()

    selectObject: .base
    if .pair != undefined and .pair
      plusObject: .pair
    endif

    @getEditorType()
    .editor_command$ = getEditorType.return$
    if .editor_command$ != ""
      do(.editor_command$)
    endif

    nocheck editor '.editor_name$'
      # Hook right after opening the editor
      @inEditor()
      if inEditor.return
        @viewEach_atBeginEditor()
      endif
    nocheck endeditor

    @viewEach_pause()

    # If objects are renamed while viewing each, editors are
    # not closed properly. Attempted to solve
    # this, but it didn't work. Why?

    if .pair != undefined and .pair
      nocheck selectObject: .pair
      if numberOfSelected()
        .editor_name$ = .pair_type$ + " " + selected$(.pair_type$)
      endif
    else
      nocheck selectObject: .base
      if numberOfSelected()
        .editor_name$ = .base_type$ + " " + selected$(.base_type$)
      endif
    endif

    nocheck editor '.editor_name$'
      # Hook within editor, after the pause
      @inEditor()
      if inEditor.return
        @viewEach_atEndEditor()
      endif
    nocheck endeditor

    # Hook called after atEndEditor, which might not be in an editor
    @viewEach_afterEndEditor()

    # Hook called immediately befre the end of the iteration
    @viewEach_atEndIteration()
  endif
endproc

procedure viewEach_cleanUp ()
endproc

# Hooks
# A previously existing definition of these procedures
# will get executed for every iteration of the script.
procedure viewEach_atBeginIteration ()
endproc

procedure viewEach_atBeginEditor ()
endproc

procedure viewEach_atEndEditor ()
  Close
endproc

procedure viewEach_afterEndEditor ()
endproc

procedure viewEach_atEndIteration ()
endproc

procedure viewEach_pause ()
  beginPause: "Viewing " + viewEach.base_name$ + " " +
    ... "(" + string$(viewEach.i) + " of " + string$(viewEach.n) + ")"

  if viewEach.i > 1
    .button = endPause: "Stop", "Previous", if viewEach.i = viewEach.n then
      ... "Finish" else "Next" fi, 3, 1
  else
    .button = endPause: "Stop", if viewEach.i = viewEach.n then 
      ... "Finish" else "Next" fi, 2, 1
  endif

  if .button = 1
    # Pressed stop
    .next = 0
  elsif .button = 2 and viewEach.i > 1
    # Pressed back
    .next = -1
  else
    # Pressed forward
    .next = if viewEach.i = viewEach.n then 0 else 1 fi
  endif
endproc

procedure inEditor ()
  .info$ = nocheck Editor info
  .return = if .info$ = "" then 0 else 1 fi
endproc

procedure getEditorType ()
  .return$ = ""
  @_TestEditor("View")
  if "'_TestEditor.return$'" != ""
  .return$ = "'_TestEditor.return$'"
  else
    @_TestEditor("View & Edit")
    .return$ = "'_TestEditor.return$'"
  endif
endproc

procedure _TestEditor (.cmd$)
  nocheck do(.cmd$)
  nocheck editor 'full_name$'
  @inEditor()
  nocheck Close
  nocheck endeditor
  .return$ = if inEditor.return then .cmd$ else "" fi
endproc
