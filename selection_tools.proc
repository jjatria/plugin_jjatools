# Selection tools
#
# For a program in which command options are so dependant on the
# current selection, support for common used selection actions is
# notably lacking in Praat. This is a first attempt at solving this.
#
# This is a set of procedure that make it easy to save and restore
# any number of object selections, as well as perform other related
# tasks (clear the selection, count types of objects, etc).
#
# Written by Jose J. Atria (3 July 2014)
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# A copy of the GNU General Public License is available at
# <http://www.gnu.org/licenses/>.

#
# Procedures
#

# Save the active selection
#
# The selection is saved in the internal pseudo-array .id,
# which is accessed internally by @restoreSelection() to
# restore this anonymous selection.
#
procedure saveSelection ()
#   appendInfoLine: "saveSelection"
  .n = numberOfSelected()
  for .i to .n
    .id[.i] = selected(.i)
  endfor
  
  @restoreSelection()
endproc

# Saves the active selection to a selection table
#
# Selection tables are used by these procedures to represent
# a selection and store its data. This procedure is used
# to create a table representing the current selection.
#
# Using this table it is easy to create per-type sub-sets of the current
# selection, by using the Extract rows where...-like commands:
#
#     @saveSelectionTable()
#     table = saveSelectionTable.table
#     sounds = Extract rows where column (text): "type", "is equal to", "Sound"
#     selectObject: table
#     pitchs = Extract rows where column (text): "type", "is equal to", "Pitch"
#
# Although this is probably done more quickly by using the
# @selectType(type$) or @refineToType(type$) procedures
# depending on whether the entire object list or only the
# current selection should be considered (note that these
# do not alter the current selection):
#
#     @saveSelection()
#     @selectType("Sound")
#     @saveSelectionTable()
#     sounds = saveSelectionTable.table
#     @restoreSelection()
#
procedure saveSelectionTable ()
#   appendInfoLine: "saveSelectionTable"
  .n = numberOfSelected()
  for .i to .n
    .id[.i] = selected(.i)
  endfor
  
  .table = Create Table with column names: "selection_table", .n, "type name n id"
  
  for .i to .n
    selectObject: .id[.i]
    .type$ = extractWord$(selected$(), "")
    .name$ = extractWord$(selected$(), .type$)
    
    selectObject: .table
    Set string value:  .i, "type", .type$
    Set string value:  .i, "name", .name$
    Set numeric value: .i, "n",    1
    Set numeric value: .i, "id",   .id[.i]
  endfor
  
  @restoreSavedSelection(.table)
endproc

# Restores the last saved selection
#
# Upon being called, this will restore the selection available in the internal
# variables of @saveSelection.
#
procedure restoreSelection ()
#   appendInfoLine: "restoreSelection"
  if variableExists("saveSelection.n")
    nocheck selectObject: undefined
    for .i to saveSelection.n
      plusObject: saveSelection.id[.i]
    endfor
  else
    exitScript: "No selection saved"
  endif
endproc

# Restores a selection using a selection table
#
# When called with the id of a previously generated selection table (by
# calling @saveSelection(1), for example), it will restore the selection saved
# in that table.
#
procedure restoreSavedSelection (.id)
  appendInfoLine: "restoreSavedSelection"
  nocheck selectObject: undefined
  @plusSavedSelection(.id)
endproc

procedure plusSavedSelection (.id)
  appendInfoLine: "plusSavedSelection"
  @_loadSelectionTable(.id, 1)
endproc

procedure minusSavedSelection (.id)
  appendInfoLine: "minusSavedSelection"
  @_loadSelectionTable(.id, -1)
endproc

procedure _loadSelectionTable (.id, .plus)
  appendInfoLine: "_loadSelectionTable"
  @isSelectionTable(.id)
  if isSelectionTable.return
    selectObject: .id
      
    .n = Get number of rows
    for .i to .n
      .id[.i] = Get value: .i, "id"
    endfor
    
    for .i to .n
      if .plus
        plusObject: .id[.i]
      else
        minusObject: .id[.i]
      endif
    endfor
    
    minusObject: .id
  else
    exitScript: "Object ", .id, " is not a selection table"
  endif
endproc

# Safely and silently clears the selection
#
procedure clearSelection ()
#   appendInfoLine: "clearSelection"
  nocheck selectObject(undefined)
endproc

# Generate a table with information about the current selection
#
# This procedure generates a table with the types of objects selected and the
# number of selected objects per type. This can then be used to check for
# parity between multiple object types (for instance, for pairing Sounds and
# TextGrids).
#
procedure checkSelection ()
#   appendInfoLine: "checkSelection"
  .n = numberOfSelected()

  if .n
    @saveSelectionTable()
    .selected = saveSelectionTable.table
    
    selectObject: .selected
    .table = Collapse rows: "type", "n", "", "", "", ""
    Rename: "object_table"

    .variance = Get standard deviation: "n"
    .return = if .variance = 0 then 1 else 0 fi

    @restoreSavedSelection(.selected)
    removeObject: .selected
  else
    .return = -1
  endif
endproc

# Checks if the object with a specific id is a (or looks like a) valid
# selection table
#
# Mostly for internal use. This procedure modifies the current selection!
#
procedure isSelectionTable (.id)
#   appendInfoLine: "isSelectionTable"
  .return = 0
  @objectExists(.id)
  if numberOfSelected("Table")
    .columns$ = List: 0
    .columns$ = left$(.columns$, index(.columns$, newline$) - 1)
    if .columns$ = "type" + tab$ + "name" + tab$ + "n" + tab$ + "id"
      .return = 1
    endif
  endif
endproc

# Selects all existing selection tables
#
# This procedure will select all existing tables that look like selection
# tables. This is mostly for use with @removeSelectionTables(), which makes it
# safer.
#
procedure selectSelectionTables ()
#   appendInfoLine: "selectSelectionTables"
  select all
  .t = 0
  .n = numberOfSelected()
  for .i to .n
    .o[.i] = selected(.i)
  endfor
  for .i to .n
    @isSelectionTable(.o[.i])
    if isSelectionTable.return
      .t += 1
      .tables[.t] = .o[.i]
    endif
  endfor
  
  if .t
    @clearSelection()
    for .i to .t
      plusObject(.tables[.i])
    endfor
  endif
endproc

# Erases all existing selection tables
#
# Use with extreme care! This procedure will remove all existing tables that
# look like selection tables. The detection is specific enough to avoid errors
# in most cases, but anything that uses `select all` should be mistrusted.
#
# This procedure uses @saveSelection() internally, so it will clear the last
# saved selection!
#
procedure removeSelectionTables ()
#   appendInfoLine: "removeSelectionTables"
  @saveSelection(0)
  
  @selectSelectionTables()
  .n = numberOfSelected()
  if .n
    Remove
  endif
  
  @restoreSelection()
endproc

# Checks if the object with a specific id is a (or looks like a) valid
# object table
#
# Mostly for internal use. This procedure modifies the current selection!
#
procedure isObjectTypeTable (.id)
#   appendInfoLine: "isObjectTypeTable"
  .return = 0
  @objectExists(.id)
  if numberOfSelected("Table")
    .columns$ = List: 0
    .columns$ = left$(.columns$, index(.columns$, newline$) - 1)
    if .columns$ = "type" + tab$ + "n"
      .return = 1
    endif
  endif
endproc

# Checks if a string represents a valid object type
#
procedure isValidType (.type$)
#   appendInfoLine: "isValidType"
  .objects$ = List readable types of objects
  .objects$ = replace_regex$(.objects$, ".*\t(.*)$", "\1", 0)
  .objects$ = replace$(.objects$, newline$, " ", 0)
  .objects$ = " " + .objects$ + " "
  .return = if index(.objects$, " " + .type$ + " ") then 1 else 0 fi
endproc

# Selects only one type from the entire object list
#
procedure selectType (.type$)
#   appendInfoLine: "selectType"
  @isValidType(.type$)
  select all
  @refineToType(.type$)
endproc

# Selects only one type from the active selection
#
procedure refineToType (.type$)
#   appendInfoLine: "refineToType"
  @isValidType(.type$)
  if isValidType.return
    @saveSelectionTable()
    selectObject: saveSelectionTable.table
    .per_type = nowarn Extract rows where column (text): "type", "is equal to", .type$
    @restoreSavedSelection(.per_type)
    removeObject: saveSelectionTable.table, .per_type
  else
    exitScript: """", .type$, """ is not a valid Praat type"
  endif
endproc

# Selects all existing object tables
#
# This procedure will select all existing tables that look like object tables.
# This is mostly for use with @removeSelectionTables(), which makes it safer.
#
procedure selectObjectTables ()
#   appendInfoLine: "selectObjectTables"
  @selectType("Table")
  .n = numberOfSelected()
  for .i to .n
    .o[.i] = selected(.i)
  endfor
  for .i to .n
    @isObjectTable(.o[.i])
    if !isObjectTable.return
      minusObject(.o[.i])
    endif
  endfor
endproc

# Erases all existing object tables
#
# Use with extreme care! This procedure will remove all existing tables that
# look like object tables. The detection is specific enough to avoid errors
# in most cases, but anything that uses `select all` should be mistrusted.
#
procedure removeObjectTables ()
#   appendInfoLine: "removeObjectTables"
  @saveSelectionTable()
  .selected = saveSelectionTable.table
  
  @selectObjectTables()
  minusObject(.selected)
  nocheck Remove
  
  @restoreSavedSelection(.selected)
  removeObject(.selected)
endproc

# Counts the type of objects from an object table
#
# Provide the id of the object table and the name of the object type to count
#
procedure countObjects (.id, .type$)
#   appendInfoLine: "countObjects"
  @isObjectTypeTable(.id)
  if isObjectTypeTable.return
  
    selectObject: .id
    .row = nowarn Search column: "type", .type$
    if .row
      .n = Get value: .row, "n"
    else
      .n = .row
    endif
  endif
endproc

# Checks if an object exists in the object list
#
# This procedure changes the current selection!
#
procedure objectExists (.id)
  nocheck selectObject: .id
  .return = if numberOfSelected() = 1 then 1 else 0 fi
endproc
