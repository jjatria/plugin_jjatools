# Selection tools
#
# For a program in which command options are so dependant on the
# current selection, support for common used selection actions is
# notably lacking in Praat. This is a first attempt at solving this.
#
# This is a set of procedure that make it easy to save and restore
# any number of object selections, as well as perform other related
# tasks (clear the selection, count types of objects, etc).
#
# Written by Jose J. Atria (3 July 2014)
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# A copy of the GNU General Public License is available at
# <http://www.gnu.org/licenses/>.

#
# Procedures
#

# Save the active selection
#
# The selection is saved in the internal pseudo-array .id unless .keep is set
# true. In that case, a selection table with the current selection is kept
# and its id saved in the internal variable .table. This can then be used to
# restore this particular selection, in the case multiple selections need to
# be saved
#
# Using this table it is easy to create per-type sub-sets of the current
# selection, by using the Extract rows where...-like commands:
#
#     @saveSelection(1)
#     table = saveSelection.table
#     sounds = Extract rows where column (text): "type", "is equal to", "Sound"
#     selectObject: table
#     pitchs = Extract rows where column (text): "type", "is equal to", "Pitch"
#
#
procedure saveSelection (.keep)
  .n = numberOfSelected()
  for .i to .n
    .id[.i] = selected(.i)
  endfor
  
  if .n
    .table = Create Table with column names: "selected_objects", .n, "type name n id"
  endif
  
  for .i to .n
    selectObject: .id[.i]
    .type$ = extractWord$(selected$(), "")
    .name$ = extractWord$(selected$(), .type$)
    
    selectObject: .table
    Set string value:  .i, "type", .type$
    Set string value:  .i, "name", .name$
    Set numeric value: .i, "n",    1
    Set numeric value: .i, "id",   .id[.i]
  endfor
  
  @restoreSelection()
  
  if .n and !.keep
    removeObject(.table)
  endif
endproc

# Restores the last saved selection
#
# Upon being called, this will restore the selection available in the internal
# variables of @saveSelection.
#
procedure restoreSelection ()
  if variableExists("saveSelection.n")
    @clearSelection()
    for .i to saveSelection.n
      plusObject: saveSelection.id[.i]
    endfor
  else
    exitScript: "No selection saved"
  endif
endproc

# Restores a selection using a selection table
#
# When called with the id of a previously generated selection table (by
# calling @saveSelection(1), for example), it will restore the selection saved
# in that table.
#
procedure restoreSavedSelection (.id)
  @isSelectionTable(.id)
  if isSelectionTable.return
    selectObject: .id
      
    .n = Get number of rows
    if .n
      for .i to .n
        .id[.i] = Get value: .i, "id"
      endfor
      
      @clearSelection()
      for .i to .n
        plusObject: .id[.i]
      endfor
    else
      exitScript: "Selection table is empty"
    endif
  else
    exitScript: "Object ", .id, " is not a selection table"
  endif
endproc

# Safely and silently clears the selection
#
procedure clearSelection ()
  nocheck selectObject(undefined)
endproc

# Generate a table with information about the current selection
#
# This procedure generates a table with the types of objects selected and the
# number of selected objects per type. This can then be used to check for
# parity between multiple object types (for instance, for pairing Sounds and
# TextGrids).
#
procedure checkSelection ()
  .n = numberOfSelected()

  if .n
    @saveSelection(1)
    .raw_table = saveSelection.table
    
    selectObject: .raw_table
    .object_table = Collapse rows: "type", "n", "", "", "", ""
    selectObject: .object_table

    .variance = Get standard deviation: "n"
    .result = if .variance = 0 then 1 else 0 fi

    @restoreSelection()
  else
    .result = -1
  endif
endproc

# Checks if the object with a specific id is a (or looks like a) valid
# selection table
#
# Mostly for internal use
#
procedure isSelectionTable (.id)
  .return = 0
  @objectExists(.id)
  if !objectExists.return
    exitScript: "Object ", .id, " does not exist"
  endif
  
  if numberOfSelected("Table")
    columns$ = List: 0
    columns$ = left$(columns$, index(columns$, newline$) - 1)
    if columns$ = "type'tab$'name'tab$'n'tab$'id"
      .return = 1
    endif
  endif
endproc

# Selects all existing selection tables
#
# This procedure will select all existing tables that look like selection
# tables. This is mostly for use with @removeSelectionTables(), which makes it
# safer.
#
procedure selectSelectionTables ()
  select all
  .t = 0
  .n = numberOfSelected()
  for .i to .n
    .o[.i] = selected(.i)
  endfor
  for .i to .n
    @isSelectionTable(.o[.i])
    if isSelectionTable.return
      .t = .t + 1
      .tables[.t] = .o[.i]
    endif
  endfor
  if .t
    @clearSelection()
    for .i to .t
      plusObject(.tables[.t])
    endfor
  endif
endproc

# Erases all existing selection tables
#
# Use with extreme care! This procedure will remove all existing tables that
# look like selection tables. The detection is specific enough to avoid errors
# in most cases, but anything that uses `select all` should be mistrusted.
#
# This procedure uses @saveSelection() internally, so it will clear the last
# saved selection!
#
procedure removeSelectionTables ()
  @saveSelection(0)
  
  @selectSelectionTables()
  .n = numberOfSelected()
  if .n
    Remove
  endif
  
  @restoreSelection()
endproc

# Checks if the object with a specific id is a (or looks like a) valid
# object table
#
# Mostly for internal use
#
procedure isObjectTypeTable (.id)
  .return = 0
  @objectExists(.id)
  if numberOfSelected("Table")
    columns$ = List: 0
    columns$ = left$(columns$, index(columns$, newline$) - 1)
    if columns$ = "type'tab$'n"
      .return = 1
    endif
  endif
endproc

# Selects all existing object tables
#
# This procedure will select all existing tables that look like object tables.
# This is mostly for use with @removeSelectionTables(), which makes it safer.
#
procedure selectObjectTables ()
  select all
  .n = numberOfSelected()
  for .i to .n
    .o[.i] = selected(.i)
  endfor
  for .i to .n
    @isObjectTable(.o[.i])
    if !isObjectTable.return
      minusObject(.o[.i])
    endif
  endfor
endproc

# Erases all existing object tables
#
# Use with extreme care! This procedure will remove all existing tables that
# look like object tables. The detection is specific enough to avoid errors
# in most cases, but anything that uses `select all` should be mistrusted.
#
procedure removeObjectTables ()
  @saveSelection(0)
  
  @selectObjectTables()
  .n = numberOfSelected()
  if .n
    Remove
  endif
  
  @restoreSelection()
endproc

# Counts the type of objects from an object table
#
# Provide the id of the object table and the name of the object type to count
#
procedure countObjects (.id, .type$)
  @isObjectTypeTable(.id)
  if isObjectTypeTable.return
  
    selectObject: .id
    .row = nowarn Search column: "type", .type$
    if .row
      .n = Get value: .row, "n"
    else
      .n = .row
    endif
  endif
endproc

# Checks if an object exists in the object list
#
procedure objectExists (.id)
  nocheck selectObject: .id
  .return = if numberOfSelected() = 1 then 1 else 0 fi
endproc
