# Selection tools
#
# For a program in which command options are so dependant on the
# current selection, support for common used selection actions is
# notably lacking in Praat. This is a first attempt at solving this.
#
# This is a set of procedure that make it easy to save and restore
# any number of object selections, as well as perform other related
# tasks (clear the selection, count types of objects, etc).
#
# Written by Jose J. Atria (3 July 2014)
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# A copy of the GNU General Public License is available at
# <http://www.gnu.org/licenses/>.

jja.config$ = readFile$("config.ini")
jja.debug = extractNumber(jja.config$, "DEBUG=")

#
# Procedures
#

# Save the active selection
#
# The selection is saved in the internal pseudo-array .id,
# which is accessed internally by @restoreSelection() to
# restore this anonymous selection.
#
procedure saveSelection ()
  if jja.debug
    appendInfoLine: "saveSelection()"
  endif
  
  .n = numberOfSelected()
  for .i to .n
    .id[.i] = selected(.i)
  endfor
  
  @restoreSelection()
endproc

# Saves the active selection to a selection table
#
# Selection tables are used by these procedures to represent
# a selection and store its data. This procedure is used
# to create a table representing the current selection.
#
# Using this table it is easy to create per-type sub-sets of the current
# selection, by using the Extract rows where...-like commands:
#
#     @saveSelectionTable()
#     table = saveSelectionTable.table
#     sounds = Extract rows where column (text): "type", "is equal to", "Sound"
#     selectObject: table
#     pitchs = Extract rows where column (text): "type", "is equal to", "Pitch"
#
# Although this is probably done more quickly by using the
# @selectType(type$) or @refineToType(type$) procedures
# depending on whether the entire object list or only the
# current selection should be considered (note that the example below
# does not alter the current selection):
#
#     @saveSelection()
#     @selectType("Sound")
#     @saveSelectionTable()
#     sounds = saveSelectionTable.table
#     @restoreSelection()
#
# After that, the variable "sounds" holds the id of a table representing
# the selection of all Sound objects in the object list.
#
procedure saveSelectionTable ()
  if jja.debug
    appendInfoLine: "saveSelectionTable()"
  endif
  
  .n = numberOfSelected()
  for .i to .n
    .id[.i] = selected(.i)
  endfor
  
  @createEmptySelectionTable()
  .table = createEmptySelectionTable.table
  
  for .i to .n
    @_AppendToSelectionTable(.table, .id[.i])
  endfor
  
  @restoreSavedSelection(.table)
endproc

procedure createSelectionTable (.n)
  if jja.debug
    appendInfoLine: "createSelectionTable(", .n, ")"
  endif
  
  .table = Create Table with column names: "selection_table", .n, "type name n id"
endproc

procedure createEmptySelectionTable ()
  if jja.debug
    appendInfoLine: "createEmptySelectionTable()"
  endif

  @createSelectionTable(0)
  .table = createSelectionTable.table
endproc

procedure addToSelectionTable (.table, .id)
  if jja.debug
    appendInfoLine: "addToSelectionTable(", .table, ", ", .id, ")"
  endif

  @isSelectionTable(.table)
  @objectExists(.id)
  if isSelectionTable.return and objectExists.return
    @saveSelectionTable()
    .selected = saveSelectionTable.table

    @restoreSavedSelection(.table)
    @isSelected(.id)
    if !isSelected.return
      @_AppendToSelectionTable(.table, .id)
    else  
      appendInfoLine: "append failed"
    endif
    
    @restoreSavedSelection(.selected)
    removeObject: .selected
  endif
endproc

procedure _AppendToSelectionTable (.table, .id)
  if jja.debug
    appendInfoLine: "_AppendToSelectionTable(", .table, ", ", .id, ")"
  endif

  selectObject: .id
  .type$ = extractWord$(selected$(), "")
  .name$ = extractWord$(selected$(), .type$)

  selectObject: .table
  Append row
  .r = Get number of rows
  Set string value:  .r, "type", .type$
  Set string value:  .r, "name", .name$
  Set numeric value: .r, "n",    1
  Set numeric value: .r, "id",   .id
endproc

# Restores the last saved selection
#
# Upon being called, this will restore the selection available in the internal
# variables of @saveSelection.
#
procedure restoreSelection ()
  if jja.debug
    appendInfoLine: "restoreSelection()"
  endif

  if variableExists("saveSelection.n")
    @clearSelection()
    for .i to saveSelection.n
      plusObject: saveSelection.id[.i]
    endfor
  else
    exitScript: "No selection saved"
  endif
endproc

# Restores a selection using a selection table
#
# When called with the id of a previously generated selection table (by
# calling @saveSelection(my_selection), for example), it will restore the
# selection saved in that table.
#
procedure restoreSavedSelection (.id)
  if jja.debug
    appendInfoLine: "restoreSavedSelection (", .id, ")"
  endif
  
  @isSelectionTable(.id)
  if isSelectionTable.return
    selectObject: .id
      
    .n = Get number of rows
    for .i to .n
      .id[.i] = Get value: .i, "id"
    endfor
    
    for .i to .n
      plusObject: .id[.i]
    endfor
    
    minusObject: .id
  else
    exitScript: "Object ", .id, " is not a selection table"
  endif
endproc

# Adds the selection in a selection table to the current selection
#
procedure plusSavedSelection (.id)
  if jja.debug
    appendInfoLine: "plusSavedSelection(", .id, ")"
  endif

  @saveSelectionTable()
  .table = saveSelectionTable.table
  selectObject: .table, .id
  .new = Append
  @restoreSavedSelection(.new)
  removeObject: .table, .new
endproc

# Removes the selection in a selection table from the current selection
#
procedure minusSavedSelection (.id)
  if jja.debug
    appendInfoLine: "minusSavedSelection(", .id, ")"
  endif

  @saveSelectionTable()
  .table = saveSelectionTable.table
  selectObject: .id

  .n = Get number of rows
  for .y from 0 to .n-1
    .i = .n - .y
    selectObject: .id
    .remove = Get value: .i, "id"
    selectObject: .table
    .remove = nowarn Search column: "id", string$(.remove)
    if .remove
      Remove row: .remove
    endif
  endfor
  
  @restoreSavedSelection(.table)
  removeObject: .table
endproc

# Safely and silently clears the selection
#
procedure clearSelection ()
  if jja.debug
    appendInfoLine: "clearSelection()"
  endif

  nocheck selectObject(undefined)
endproc

# Generate a table with information about the current selection
#
# This procedure generates a table with the types of objects selected and the
# number of selected objects per type. This can then be used to check for
# parity between multiple object types (for instance, for pairing Sounds and
# TextGrids).
#
procedure checkSelection ()
  if jja.debug
    appendInfoLine: "checkSelection()"
  endif

  .n = numberOfSelected()

  if .n
    @saveSelectionTable()
    .selected = saveSelectionTable.table
    
    selectObject: .selected
    .table = Collapse rows: "type", "n", "", "", "", ""
    Rename: "object_table"

    .variance = Get standard deviation: "n"
    .return = if .variance = 0 then 1 else 0 fi

    @restoreSavedSelection(.selected)
    removeObject: .selected
  else
    .return = -1
  endif
endproc

procedure makeObjectTable (.id)
  if jja.debug
    appendInfoLine: "makeObjectTable(", .id, ")"
  endif

  @saveSelectionTable()
  .selected = saveSelectionTable.table

  @isSelectionTable(.id)
  if isSelectionTable.return
    selectObject: .id
    
    .table = Collapse rows: "type", "n", "", "", "", ""
    Rename: "object_table"

  endif
  
  @restoreSavedSelection(.selected)
  removeObject: .selected
endproc

# Checks if the object with a specific id is a (or looks like a) valid
# selection table
#
# Mostly for internal use.
#
procedure isSelectionTable (.table)
  if jja.debug
    appendInfoLine: "isSelectionTable(", .table, ")"
  endif

  .return = 0
  
  # Hack to restore selection avoiding procedure-call loop
  .n = numberOfSelected()
  for .i to .n
    .id[.i] = selected(.i)
  endfor
  
  @objectExists(.table)
  if objectExists.return
    selectObject: .table
    if numberOfSelected("Table")
      .columns$ = List: 0
      .columns$ = left$(.columns$, index(.columns$, newline$) - 1)
      if .columns$ = "type" + tab$ + "name" + tab$ + "n" + tab$ + "id"
        .return = 1
      endif
    endif
  endif
  
  # Hack to restore selection avoiding procedure-call loop
  @clearSelection()
  for .i to .n
    plusObject: .id[.i]
  endfor
endproc

# Selects all existing selection tables
#
# This procedure will select all existing tables that look like selection
# tables. This is mostly for use with @removeSelectionTables(), which makes it
# safer.
#
procedure selectSelectionTables ()
  if jja.debug
    appendInfoLine: "selectSelectionTables()"
  endif

  select all
  .t = 0
  .n = numberOfSelected()
  for .i to .n
    .o[.i] = selected(.i)
  endfor
  for .i to .n
    @isSelectionTable(.o[.i])
    if isSelectionTable.return
      .t += 1
      .tables[.t] = .o[.i]
    endif
  endfor
  
  if .t
    @clearSelection()
    for .i to .t
      plusObject(.tables[.i])
    endfor
  endif
endproc

# Erases all existing selection tables
#
# Use with extreme care! This procedure will remove all existing tables that
# look like selection tables. The detection is specific enough to avoid errors
# in most cases, but anything that uses `select all` should be mistrusted.
#
# This procedure uses @saveSelection() internally, so it will clear the last
# saved selection!
#
procedure removeSelectionTables ()
  if jja.debug
    appendInfoLine: "removeSelectionTables()"
  endif

  @saveSelection()
  
  @selectSelectionTables()
  .n = numberOfSelected()
  if .n
    Remove
  endif
  
  @restoreSelection()
endproc

# Checks if the object with a specific id is a (or looks like a) valid
# object table
#
# Mostly for internal use.
#
procedure isObjectTypeTable (.id)
  if jja.debug
    appendInfoLine: "isObjectTypeTable(", .id, ")"
  endif

  .return = 0
  @saveSelectionTable()
  .selected = saveSelectionTable.table
  
  @objectExists(.id)
  if objectExists.return
    selectObject: .id
    .columns$ = List: 0
    .columns$ = left$(.columns$, index(.columns$, newline$) - 1)
    if .columns$ = "type" + tab$ + "n"
      .return = 1
    endif
  endif
  
  @restoreSavedSelection(.selected)
  removeObject: .selected
endproc

# Checks if a string represents a valid object type
#
procedure isValidType (.type$)
  if jja.debug
    appendInfoLine: "isValidType(", .type$, ")"
  endif

  .objects$ = List readable types of objects
  .objects$ = replace_regex$(.objects$, ".*\t(.*)$", "\1", 0)
  .objects$ = replace$(.objects$, newline$, " ", 0)
  .objects$ = " " + .objects$ + " "
  .return = if index(.objects$, " " + .type$ + " ") then 1 else 0 fi
endproc

# Selects only one type from the entire object list
#
procedure selectType (.type$)
  if jja.debug
    appendInfoLine: "selectType(", .type$, ")"
  endif

  @isValidType(.type$)
  select all
  @refineToType(.type$)
endproc

# Selects only one type from the active selection
#
procedure refineToType (.type$)
  if jja.debug
    appendInfoLine: "refineToType(", .type$, ")"
  endif

  @isValidType(.type$)
  if isValidType.return
    @saveSelectionTable()
    selectObject: saveSelectionTable.table
    .per_type = nowarn Extract rows where column (text): "type", "is equal to", .type$
    @restoreSavedSelection(.per_type)
    removeObject: saveSelectionTable.table, .per_type
  else
    exitScript: """", .type$, """ is not a valid Praat type"
  endif
endproc

# Selects all existing object tables
#
# This procedure will select all existing tables that look like object tables.
# This is mostly for use with @removeSelectionTables(), which makes it safer.
#
procedure selectObjectTables ()
  if jja.debug
    appendInfoLine: "selectObjectTables()"
  endif

  @selectType("Table")
  .n = numberOfSelected()
  for .i to .n
    .o[.i] = selected(.i)
  endfor
  for .i to .n
    @isObjectTable(.o[.i])
    if !isObjectTable.return
      minusObject(.o[.i])
    endif
  endfor
endproc

# Erases all existing object tables
#
# Use with extreme care! This procedure will remove all existing tables that
# look like object tables. The detection is specific enough to avoid errors
# in most cases, but anything that uses `select all` should be mistrusted.
#
procedure removeObjectTables ()
  if jja.debug
    appendInfoLine: "removeObjectTables()"
  endif

  @saveSelectionTable()
  .selected = saveSelectionTable.tale
  
  @selectObjectTables()
  minusObject(.selected)
  nocheck Remove
  
  @restoreSavedSelection(.selected)
  removeObject(.selected)
endproc

# Counts the type of objects from an object table
#
# Provide the id of the object table and the name of the object type to count
#
procedure countObjects (.id, .type$)
  if jja.debug
    appendInfoLine: "countObjects(", .id, ", ", .type$, ")"
  endif

  @isObjectTypeTable(.id)
  if isObjectTypeTable.return
  
    selectObject: .id
    .row = nowarn Search column: "type", .type$
    if .row
      .n = Get value: .row, "n"
    else
      .n = .row
    endif
  endif
endproc

# Checks if an object exists in the object list
#
procedure objectExists (.id)
  if jja.debug
    appendInfoLine: "objectExists(", .id, ")"
  endif

  .start = numberOfSelected()
  nocheck plusObject: .id
  .plus = numberOfSelected()
  nocheck minusObject: .id
  .minus = numberOfSelected()
  
  if .plus = .minus
    # Object does not exist
    .return = 0
  else
    .return = 1
    if .start < .plus
      minusObject: .id
    else
      plusObject: .id
    endif
  endif
endproc

procedure isSelected (.id)
  if jja.debug
    appendInfoLine: "isSelected(", .id, ")"
  endif

  .n = numberOfSelected()
  .return = 0
  for .i to .n
    if selected(.i) = .id
      .return = 1
    endif
  endfor
endproc
